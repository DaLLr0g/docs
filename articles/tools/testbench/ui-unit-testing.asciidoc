---
title: UI Unit Testing
order: 160
layout: page
---

[[testbench.uiunit]]
= UI Unit Testing

[[testbench.uiunit.introduction]]
== Introduction

UI Unit Testing removes the necessity to run both the browser and the servlet container, to test your Vaadin-based applications faster.

- container-less testing: You do not need to launch the servlet container. UI Unit Testing creates Vaadin Session, the UI and other necessary Vaadin classes straight in the JVM which runs your JUnit tests.
- browser-less testing: You look up components straight from [methodname]`UI.getCurrent()`, bypassing browser and the JavaScript->Server bridge. You directly call methods on your server-side View classes and on the server-side Java Vaadin components.

[[testbench.uiunit.why-unit-testing]]
== Why Unit Testing?

Advantages of unit testing over the end-to-end testing with TestBench:

* Fast: browser-less tests are typically 100x faster than Selenium-based tests and run in 5 to 60 milliseconds, depending on their complexity.
* Reliable: no arbitrary sleeps are needed since test is executed on server-side and it can await until the request is fully processed. No random failures because of Selenium drivers browser incompatibility.
* Headless: the tests run headless since there's no browser. No need to setup screen in your CI environment.
* Robust: the test runs in the same JVM as the server side components. If the server side bootstrap fails and throws an exception, the test method fails with the same exception. No need to go hunting for exceptions in a log located somewhere on a CI server.
* No need to write massive set of Page Objects. You are already on the server, and you have access to the actual Java components which already are providing you with high-level APIs, exactly as Page Objects do.
* Full access to the Database: You're server-side - you can access the database from your tests the same way your business logic accesses the database. You can run a bunch of SQLs to restore the database to a known state before every test. Even better - you can run the test in a transaction then roll back after the test, to perform fast database revert to a known state.

With this technique you can run 600 UI tests in 7 seconds, as opposing to 1 to 2 hours with Selenium-based approach.
Because of the speed, you can let the UI tests run after every commit by your continuous integration server.
Bypassing the browser and talking to Vaadin server API directly, eliminates the need to start the servlet container.
You can add the server jars onto testing classpath and call Vaadin server API which, in turn, invokes your server logic.

[[testbench.uiunit.limitations]]
== Limitations

UI Unit Testing is designed to bypass browser and the servlet container.
This means that it is impossible to test JavaScript code, templates and other client side functionalities.
If you need to test client side features, you need to use browser-based integration tests with TestBench.

[[testbench.uiunit.getting-started]]
== Getting Started

To start Unit testing your Vaadin application, create a class that extends [classname]`UIUnitTest` (for JUnit 5) or [classname]`UIUnit4Test` (for JUnit 4).
Base class instantiates UI along with all necessary Vaadin environment, that will be available on your test methods.

[source,java]
----
class MyViewTest extends UIUnitTest {

    @Test
    void extendingBaseClass_runTest_vaadinInstancesAvailable() {
        Assertions.assertNotNull(UI.getCurrent(),
                "Expecting current UI to be available, but was not");
        Assertions.assertNotNull(VaadinService.getCurrent(),
                "Expecting VaadinService to be available up, but was not");
        Assertions.assertNotNull(VaadinRequest.getCurrent(),
                "Expecting VaadinRequest to be available up, but was not");
        Assertions.assertNotNull(VaadinResponse.getCurrent(),
                "Expecting VaadinResponse to be available up, but was not");
        Assertions.assertNotNull(VaadinSession.getCurrent(),
                "Expecting VaadinSession to be available up, but was not");
    }

}
----

By default base class scans whole classpath for routes and error views, but this behaviour can be changed for a faster bootstrap.
To restrict scan to a specific package and its sub-packages, override [methodname]`scanPackage` method and return the package name.

[source,java]
----
class MyViewTest extends UIUnitTest {

        @Override
        protected String scanPackage() {
                return MyView.class.getPackageName();
        }

}
----

[[testbench.uiunit.navigation]]
== Navigating In Unit Tests

On test initialization the loaded view will be the root view.

To navigate to another registered view the `UIUnitTest` base class contains `navigate` methods that
support navigation to different supported views.

- For a normal view with only a path defined
+
`navigate(MyView.class)`
+
`navigate("myView", MyView.class)`.
- For a view with `HasUrlParameter`
+
`navigate(MyParam.class, "parameter")`
+
`navigate("myParam/parameter", MyParam.class)`
- For a view with url template `@Route("template/:param")`
+
`navigate(Template.class, Collections.singletonMap("param", PARAMETER))`

All navigation methods will return the instantiated view so that the package private
fields can be used directly from the view for testing.

[NOTE]
Navigation by location string takes in the view class so that the initialized view can be
automatically validated to be the expected one.

.Using TextField From View
[source, java]
----
// Navigate to InputView
InputView input = navigate(InputView.class);

//Get the nameField TextField from InputView and wrap it in a test wrapper
TextFieldWrap nameField_ = $(TextFieldWrap.class, input.nameField);

// use test wrapper to set the value to do required checks and fire expected events
nameField_.setValue("User input");

// Assert in another component that the change event fired and it has the correct value
Assertions.assertEquals("User input", input.changeText.getText());
----

[[testbench.uiunit.components]]
=== Testing Components

The target of the UI Unit tests is not to test the components as is, but to simulate user
actions and data "seen" on the client side.

To help with actions and getting data there are wrappers for components that have methods for use with components.
In a UIUnitTest class wrapping a component can be done with `$(component)` or `$(Wrapper.class, component)`.

- `$(component)` will return a component specific wrapper if one can be determined for the given component or the ComponentWrap generic wrapper.
- `$(Wrapper.class, component)` always returns an instance of the given wrapper.

For each method call, where it is applicable, the wrapper methods check that the component is in a state where it could be used by the user.
This means that the component should be visible, enabled, attached to the UI and not be behind a modal component.

[NOTE]
Modality check only works when the modal component is server-side modal.

Sample test of the HelloWorld view.

.HelloWorld
[source, java]
----
@Route(value = "", layout = MainLayout.class)
public class HelloWorldView extends HorizontalLayout {

    TextField name;
    Button sayHello;

    public HelloWorldView() {
        name = new TextField("Your name");
        sayHello = new Button("Say hello");
        sayHello.addClickListener(e -> {
            Notification.show("Hello " + name.getValue());
        });

        setMargin(true);
        setVerticalComponentAlignment(Alignment.END, name, sayHello);

        add(name, sayHello);
    }
}
----

[NOTE]
The components are package protected so that we can use them directly in the UIUnitTest.

.HelloWorldViewTest
[source, java]
----
class HelloWorldViewTest extends UIUnitTest {

    @Test
    public void setText_clickButton_notificationIsShown() {
        final HelloWorldView helloView = navigate(HelloWorldView.class);

        // TextField and Button are available as package protected in the view
        // So wwe can use those simply from there
        $(TextFieldWrap.class, helloView.name).setValue("Test");
        $(ButtonWrap.class, helloView.sayHello).click();

        // Notification is not referenced in the view so we need to use the component
        // query API to find the notification that opened
        NotificationWrap notification_ = search(Notification.class).first();
        Assertions.assertEquals("Hello Test", notification_.getText());
    }
}
----

[[testbench.uiunit.wrappers]]
== Custom Test Wrappers


There are custom wrappers for components that give testing API for the component or one extending it.
Test wrappers are annotated using the `@Wraps` annotation that tells which components the wrapper is for.

Getting a generic wrapper using `$(Component.class)` will check available test wrappers if there exists one that `Wraps` the component or its supertype.
The same feature is also used when searching with `ComponentQuery` and getting the wrapper.

Custom wrappers should extend `ComponentWrap` and be defined under the package `com.vaadin.flow.component` so that it will be found when scanning.

